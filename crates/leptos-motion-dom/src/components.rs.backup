//! Motion Components for Leptos
//!
//! This module provides motion components that integrate with Leptos

use crate::{DragConfig, DragConstraints, DragAxis};
use leptos::prelude::{
    Children, Get, NodeRef, Set, ElementChild, StyleAttribute, ClassAttribute, NodeRefAttribute, OnAttribute,
    signal, Effect,
};
use leptos::*;
use leptos_motion_core::*;
use std::collections::HashMap;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use wasm_bindgen::closure::Closure;

/// Simple MotionDiv component for animated div elements
#[component]
pub fn MotionDiv(
    /// CSS class name
    #[prop(optional)]
    class: Option<String>,
    /// Inline CSS styles
    #[prop(optional)]
    style: Option<String>,
    /// Node reference for animation engine integration
    #[prop(optional)]
    node_ref: Option<NodeRef<leptos::html::Div>>,
    /// Initial animation state
    #[prop(optional)]
    initial: Option<AnimationTarget>,
    /// Target animation state
    #[prop(optional)]
    animate: Option<Rc<dyn Fn() -> AnimationTarget>>,
    /// Transition configuration
    #[prop(optional)]
    transition: Option<Transition>,
    /// Hover animation state
    #[prop(optional)]
    while_hover: Option<AnimationTarget>,
    /// Tap animation state
    #[prop(optional)]
    while_tap: Option<AnimationTarget>,
    /// Layout animation enabled
    #[prop(optional)]
    layout: Option<bool>,
    /// Drag configuration
    #[prop(optional)]
    drag: Option<DragConfig>,
    /// Drag constraints
    #[prop(optional)]
    drag_constraints: Option<DragConstraints>,
    /// Children elements
    children: Children,
) -> impl IntoView {
    // Create signals for animation state
    let (is_hovered, set_hovered) = signal(false);
    let (is_tapped, set_tapped) = signal(false);
    let (current_styles, set_styles) = signal(HashMap::<String, String>::new());
    
        // Create signals for drag state
        let (is_dragging, set_dragging) = signal(false);
        let (drag_position, set_drag_position) = signal((0.0, 0.0));
        let (drag_start_position, set_drag_start_position) = signal((0.0, 0.0));
        let (drag_velocity, set_drag_velocity) = signal((0.0, 0.0));
        let (last_drag_time, set_last_drag_time) = signal(0.0);
        let (is_animating_momentum, set_animating_momentum) = signal(false);
        
        // Clone drag config for use in multiple closures
        let drag_config = drag.clone();
        let drag_config_mousemove = drag.clone();
        let drag_config_mouseup = drag.clone();

    // Create node reference if not provided
    let node_ref = node_ref.unwrap_or_else(|| NodeRef::new());

    // Create a reactive signal for the current animation state
    let (current_animation, set_current_animation) = signal(HashMap::new());

    // Effect that tracks animation changes - this establishes reactive dependencies
    Effect::new(move |_| {
        if let Some(animate_closure) = &animate {
            // Call the closure - this should establish reactive dependencies
            let animate_target = animate_closure();
            set_current_animation.set(animate_target);
        }
    });

    // Effect that applies styles based on current animation state
    Effect::new(move |_| {
        let mut styles = HashMap::new();
        
        // Apply initial styles
        if let Some(initial_target) = &initial {
            for (key, value) in initial_target {
                styles.insert(key.clone(), value.to_string_value());
            }
        }
        
        // Apply current animation styles
        let animation_target = current_animation.get();
        for (key, value) in &animation_target {
            styles.insert(key.clone(), value.to_string_value());
        }
        
        // Apply hover styles
        if is_hovered.get() {
            if let Some(hover_target) = &while_hover {
                for (key, value) in hover_target {
                    styles.insert(key.clone(), value.to_string_value());
                }
            }
        }
        
        // Apply tap styles
        if is_tapped.get() {
            if let Some(tap_target) = &while_tap {
                for (key, value) in tap_target {
                    styles.insert(key.clone(), value.to_string_value());
                }
            }
        }
        
                // Apply drag styles
                if is_dragging.get() || is_animating_momentum.get() {
                    let (x, y) = drag_position.get();
                    styles.insert("transform".to_string(), format!("translate3d({}px, {}px, 0)", x, y));
                    if is_dragging.get() {
                        styles.insert("cursor".to_string(), "grabbing".to_string());
                    }
                }
        
        set_styles.set(styles);
    });

    // Convert styles to CSS string
    let style_string = move || {
        let mut styles = current_styles.get();
        
        // Add inline styles if provided
        if let Some(inline_style) = &style {
            styles.insert("inline".to_string(), inline_style.clone());
        }
        
        styles
            .iter()
            .filter(|(key, _)| key != &"inline")
            .map(|(key, value)| format!("{}: {}", key, value))
            .collect::<Vec<_>>()
            .join("; ")
    };

    view! {
        <div
            node_ref=node_ref
            class=class
            style=style_string()
            on:mouseenter=move |_| set_hovered.set(true)
            on:mouseleave=move |_| {
                set_hovered.set(false);
                set_tapped.set(false);
            }
            on:mousedown=move |event| {
                set_tapped.set(true);
                if drag_config.is_some() {
                    set_dragging.set(true);
                    set_animating_momentum.set(false);
                    let client_x = event.client_x() as f64;
                    let client_y = event.client_y() as f64;
                    set_drag_start_position.set((client_x, client_y));
                    set_drag_position.set((0.0, 0.0));
                    set_drag_velocity.set((0.0, 0.0));
                    set_last_drag_time.set(js_sys::Date::now());
                }
            }
                on:mousemove=move |event| {
                    if is_dragging.get() {
                        let (start_x, start_y) = drag_start_position.get();
                        let client_x = event.client_x() as f64;
                        let client_y = event.client_y() as f64;
                        let mut delta_x = client_x - start_x;
                        let mut delta_y = client_y - start_y;
                        
                        // Calculate velocity for momentum
                        let current_time = js_sys::Date::now();
                        let time_delta = current_time - last_drag_time.get();
                        if time_delta > 0.0 {
                            let (prev_x, prev_y) = drag_position.get();
                            // Velocity = change in position / time
                            let velocity_x = (delta_x - prev_x) / time_delta;
                            let velocity_y = (delta_y - prev_y) / time_delta;
                            set_drag_velocity.set((velocity_x, velocity_y));
                        }
                        set_last_drag_time.set(current_time);
                        
                        // Apply drag constraints if configured
                        if let Some(drag_config) = &drag_config_mousemove {
                            if let Some(constraints) = &drag_config.constraints {
                                // Apply axis constraints
                                match drag_config.axis {
                                    Some(DragAxis::X) => delta_y = 0.0,
                                    Some(DragAxis::Y) => delta_x = 0.0,
                                    _ => {} // Both or None - no axis constraint
                                }
                                
                                // Apply elastic boundary constraints
                                if let Some(elastic) = drag_config.elastic {
                                    if let Some(left) = constraints.left {
                                        if delta_x < left {
                                            let overshoot = left - delta_x;
                                            delta_x = left - (overshoot * elastic);
                                        }
                                    }
                                    if let Some(right) = constraints.right {
                                        if delta_x > right {
                                            let overshoot = delta_x - right;
                                            delta_x = right + (overshoot * elastic);
                                        }
                                    }
                                    if let Some(top) = constraints.top {
                                        if delta_y < top {
                                            let overshoot = top - delta_y;
                                            delta_y = top - (overshoot * elastic);
                                        }
                                    }
                                    if let Some(bottom) = constraints.bottom {
                                        if delta_y > bottom {
                                            let overshoot = delta_y - bottom;
                                            delta_y = bottom + (overshoot * elastic);
                                        }
                                    }
                                } else {
                                    // Apply hard boundary constraints
                                    if let Some(left) = constraints.left {
                                        delta_x = delta_x.max(left);
                                    }
                                    if let Some(right) = constraints.right {
                                        delta_x = delta_x.min(right);
                                    }
                                    if let Some(top) = constraints.top {
                                        delta_y = delta_y.max(top);
                                    }
                                    if let Some(bottom) = constraints.bottom {
                                        delta_y = delta_y.min(bottom);
                                    }
                                }
                            }
                        }
                        
                        set_drag_position.set((delta_x, delta_y));
                    }
                }
            on:mouseup=move |_| {
                set_tapped.set(false);
                if is_dragging.get() {
                    set_dragging.set(false);
                    
                    // Start momentum animation if enabled
                    if let Some(drag_config) = &drag_config_mouseup {
                        if drag_config.momentum.unwrap_or(false) {
                            let (velocity_x, velocity_y) = drag_velocity.get();
                            let velocity_magnitude = (velocity_x * velocity_x + velocity_y * velocity_y).sqrt();
                            
                            if velocity_magnitude > 0.1 { // Minimum velocity threshold
                                set_animating_momentum.set(true);
                                
                                // Start continuous momentum animation loop
                                let set_drag_position = set_drag_position.clone();
                                let set_drag_velocity = set_drag_velocity.clone();
                                let set_animating_momentum = set_animating_momentum.clone();
                                let drag_config = drag_config.clone();
                                let drag_position = drag_position.clone();
                                let drag_velocity = drag_velocity.clone();
                                let is_animating_momentum = is_animating_momentum.clone();
                                
                                // Start momentum animation with proper continuous loop
                                let start_momentum_animation = move || {
                                    // Create a simple momentum animation loop
                                    let momentum_step = move || {
                                        // Check if we should continue animating
                                        if !is_animating_momentum.get() {
                                            return;
                                        }
                                        
                                        let (current_x, current_y) = drag_position.get();
                                        let (velocity_x, velocity_y) = drag_velocity.get();
                                        
                                        // Apply friction (0.95 = 5% friction per frame)
                                        let friction = 0.95;
                                        let new_velocity_x = velocity_x * friction;
                                        let new_velocity_y = velocity_y * friction;
                                        
                                        // Update position based on velocity
                                        let new_x = current_x + new_velocity_x;
                                        let new_y = current_y + new_velocity_y;
                                        
                                        // Apply constraints during momentum with elastic behavior
                                        let (final_x, final_y) = if let Some(constraints) = &drag_config.constraints {
                                            let mut constrained_x = new_x;
                                            let mut constrained_y = new_y;
                                            
                                            // Apply axis constraints
                                            match drag_config.axis {
                                                Some(DragAxis::X) => constrained_y = current_y,
                                                Some(DragAxis::Y) => constrained_x = current_x,
                                                _ => {} // Both or None - no axis constraint
                                            }
                                            
                                            // Apply boundary constraints with elastic behavior
                                            let elastic_factor = drag_config.elastic.unwrap_or(0.0);
                                            
                                            if let Some(left) = constraints.left {
                                                if constrained_x < left {
                                                    if elastic_factor > 0.0 {
                                                        let overshoot = left - constrained_x;
                                                        constrained_x = left - (overshoot * elastic_factor);
                                                    } else {
                                                        constrained_x = left;
                                                    }
                                                }
                                            }
                                            if let Some(right) = constraints.right {
                                                if constrained_x > right {
                                                    if elastic_factor > 0.0 {
                                                        let overshoot = constrained_x - right;
                                                        constrained_x = right + (overshoot * elastic_factor);
                                                    } else {
                                                        constrained_x = right;
                                                    }
                                                }
                                            }
                                            if let Some(top) = constraints.top {
                                                if constrained_y < top {
                                                    if elastic_factor > 0.0 {
                                                        let overshoot = top - constrained_y;
                                                        constrained_y = top - (overshoot * elastic_factor);
                                                    } else {
                                                        constrained_y = top;
                                                    }
                                                }
                                            }
                                            if let Some(bottom) = constraints.bottom {
                                                if constrained_y > bottom {
                                                    if elastic_factor > 0.0 {
                                                        let overshoot = constrained_y - bottom;
                                                        constrained_y = bottom + (overshoot * elastic_factor);
                                                    } else {
                                                        constrained_y = bottom;
                                                    }
                                                }
                                            }
                                            
                                            (constrained_x, constrained_y)
                                        } else {
                                            (new_x, new_y)
                                        };
                                        
                                        // Update position and velocity
                                        set_drag_position.set((final_x, final_y));
                                        set_drag_velocity.set((new_velocity_x, new_velocity_y));
                                        
                                        // Check if we should stop (velocity too low)
                                        let velocity_magnitude = (new_velocity_x * new_velocity_x + new_velocity_y * new_velocity_y).sqrt();
                                        if velocity_magnitude < 0.1 {
                                            set_animating_momentum.set(false);
                                        } else {
                                            // Schedule next frame
                                            let set_drag_position = set_drag_position.clone();
                                            let set_drag_velocity = set_drag_velocity.clone();
                                            let set_animating_momentum = set_animating_momentum.clone();
                                            let drag_config = drag_config.clone();
                                            let drag_position = drag_position.clone();
                                            let drag_velocity = drag_velocity.clone();
                                            let is_animating_momentum = is_animating_momentum.clone();
                                            
                                            // Schedule next frame using a simple timeout for now
                                            // This will be enhanced with proper requestAnimationFrame scheduling
                                            let _ = web_sys::window()
                                                .unwrap()
                                                .set_timeout_with_callback_and_timeout_and_arguments_0(
                                                    &Closure::wrap(Box::new(move || {
                                                        // Recursive call to continue momentum
                                                        momentum_step();
                                                    }) as Box<dyn FnMut()>).as_ref().unchecked_ref(),
                                                    16 // ~60fps
                                                )
                                                .unwrap();
                                        }
                                    };
                                    
                                    // Start the momentum animation loop
                                    momentum_step();
                                };
                                
                                // Start the momentum animation loop
                                start_momentum_animation();
                                            let drag_velocity = drag_velocity.clone();
                                            let is_animating_momentum = is_animating_momentum.clone();
                                            
                                            // Schedule next frame
                                            let _ = web_sys::window()
                                                .unwrap()
                                                .set_timeout_with_callback_and_timeout_and_arguments_0(
                                                    &Closure::wrap(Box::new(move || {
                                                        // Continue momentum animation
                                                        let (current_x, current_y) = drag_position.get();
                                                        let (velocity_x, velocity_y) = drag_velocity.get();
                                                        
                                                        // Apply friction
                                                        let friction = 0.95;
                                                        let new_velocity_x = velocity_x * friction;
                                                        let new_velocity_y = velocity_y * friction;
                                                        
                                                        // Update position based on velocity
                                                        let new_x = current_x + new_velocity_x;
                                                        let new_y = current_y + new_velocity_y;
                                                        
                                                        // Apply constraints during momentum with elastic behavior
                                                        let (final_x, final_y) = if let Some(constraints) = &drag_config.constraints {
                                                            let mut constrained_x = new_x;
                                                            let mut constrained_y = new_y;
                                                            
                                                            // Apply axis constraints
                                                            match drag_config.axis {
                                                                Some(DragAxis::X) => constrained_y = current_y,
                                                                Some(DragAxis::Y) => constrained_x = current_x,
                                                                _ => {} // Both or None - no axis constraint
                                                            }
                                                            
                                                            // Apply boundary constraints with elastic behavior
                                                            let elastic_factor = drag_config.elastic.unwrap_or(0.0);
                                                            
                                                            if let Some(left) = constraints.left {
                                                                if constrained_x < left {
                                                                    if elastic_factor > 0.0 {
                                                                        // Elastic overshoot
                                                                        let overshoot = left - constrained_x;
                                                                        constrained_x = left - (overshoot * elastic_factor);
                                                                    } else {
                                                                        constrained_x = left;
                                                                    }
                                                                }
                                                            }
                                                            if let Some(right) = constraints.right {
                                                                if constrained_x > right {
                                                                    if elastic_factor > 0.0 {
                                                                        // Elastic overshoot
                                                                        let overshoot = constrained_x - right;
                                                                        constrained_x = right + (overshoot * elastic_factor);
                                                                    } else {
                                                                        constrained_x = right;
                                                                    }
                                                                }
                                                            }
                                                            if let Some(top) = constraints.top {
                                                                if constrained_y < top {
                                                                    if elastic_factor > 0.0 {
                                                                        // Elastic overshoot
                                                                        let overshoot = top - constrained_y;
                                                                        constrained_y = top - (overshoot * elastic_factor);
                                                                    } else {
                                                                        constrained_y = top;
                                                                    }
                                                                }
                                                            }
                                                            if let Some(bottom) = constraints.bottom {
                                                                if constrained_y > bottom {
                                                                    if elastic_factor > 0.0 {
                                                                        // Elastic overshoot
                                                                        let overshoot = constrained_y - bottom;
                                                                        constrained_y = bottom + (overshoot * elastic_factor);
                                                                    } else {
                                                                        constrained_y = bottom;
                                                                    }
                                                                }
                                                            }
                                                            
                                                            (constrained_x, constrained_y)
                                                        } else {
                                                            (new_x, new_y)
                                                        };
                                                        
                                                        // Update position and velocity
                                                        set_drag_position.set((final_x, final_y));
                                                        set_drag_velocity.set((new_velocity_x, new_velocity_y));
                                                        
                                                        // Check if we should stop momentum
                                                        let velocity_magnitude = (new_velocity_x * new_velocity_x + new_velocity_y * new_velocity_y).sqrt();
                                                        if velocity_magnitude < 0.1 {
                                                            set_animating_momentum.set(false);
                                                        } else {
                                                            // Continue the animation loop recursively
                                                            let set_drag_position = set_drag_position.clone();
                                                            let set_drag_velocity = set_drag_velocity.clone();
                                                            let set_animating_momentum = set_animating_momentum.clone();
                                                            let drag_config = drag_config.clone();
                                                            let drag_position = drag_position.clone();
                                                            let drag_velocity = drag_velocity.clone();
                                                            let is_animating_momentum = is_animating_momentum.clone();
                                                            
                                                            // Schedule next frame
                                                            let _ = web_sys::window()
                                                                .unwrap()
                                                                .set_timeout_with_callback_and_timeout_and_arguments_0(
                                                                    &Closure::wrap(Box::new(move || {
                                                                        // Continue momentum animation
                                                                        let (current_x, current_y) = drag_position.get();
                                                                        let (velocity_x, velocity_y) = drag_velocity.get();
                                                                        
                                                                        // Apply friction
                                                                        let friction = 0.95;
                                                                        let new_velocity_x = velocity_x * friction;
                                                                        let new_velocity_y = velocity_y * friction;
                                                                        
                                                                        // Update position based on velocity
                                                                        let new_x = current_x + new_velocity_x;
                                                                        let new_y = current_y + new_velocity_y;
                                                                        
                                                                        // Apply constraints during momentum with elastic behavior
                                                                        let (final_x, final_y) = if let Some(constraints) = &drag_config.constraints {
                                                                            let mut constrained_x = new_x;
                                                                            let mut constrained_y = new_y;
                                                                            
                                                                            // Apply axis constraints
                                                                            match drag_config.axis {
                                                                                Some(DragAxis::X) => constrained_y = current_y,
                                                                                Some(DragAxis::Y) => constrained_x = current_x,
                                                                                _ => {} // Both or None - no axis constraint
                                                                            }
                                                                            
                                                                            // Apply boundary constraints with elastic behavior
                                                                            let elastic_factor = drag_config.elastic.unwrap_or(0.0);
                                                                            
                                                                            if let Some(left) = constraints.left {
                                                                                if constrained_x < left {
                                                                                    if elastic_factor > 0.0 {
                                                                                        // Elastic overshoot
                                                                                        let overshoot = left - constrained_x;
                                                                                        constrained_x = left - (overshoot * elastic_factor);
                                                                                    } else {
                                                                                        constrained_x = left;
                                                                                    }
                                                                                }
                                                                            }
                                                                            if let Some(right) = constraints.right {
                                                                                if constrained_x > right {
                                                                                    if elastic_factor > 0.0 {
                                                                                        // Elastic overshoot
                                                                                        let overshoot = constrained_x - right;
                                                                                        constrained_x = right + (overshoot * elastic_factor);
                                                                                    } else {
                                                                                        constrained_x = right;
                                                                                    }
                                                                                }
                                                                            }
                                                                            if let Some(top) = constraints.top {
                                                                                if constrained_y < top {
                                                                                    if elastic_factor > 0.0 {
                                                                                        // Elastic overshoot
                                                                                        let overshoot = top - constrained_y;
                                                                                        constrained_y = top - (overshoot * elastic_factor);
                                                                                    } else {
                                                                                        constrained_y = top;
                                                                                    }
                                                                                }
                                                                            }
                                                                            if let Some(bottom) = constraints.bottom {
                                                                                if constrained_y > bottom {
                                                                                    if elastic_factor > 0.0 {
                                                                                        // Elastic overshoot
                                                                                        let overshoot = constrained_y - bottom;
                                                                                        constrained_y = bottom + (overshoot * elastic_factor);
                                                                                    } else {
                                                                                        constrained_y = bottom;
                                                                                    }
                                                                                }
                                                                            }
                                                                            
                                                                            (constrained_x, constrained_y)
                                                                        } else {
                                                                            (new_x, new_y)
                                                                        };
                                                                        
                                                                        // Update position and velocity
                                                                        set_drag_position.set((final_x, final_y));
                                                                        set_drag_velocity.set((new_velocity_x, new_velocity_y));
                                                                        
                                                                        // Check if we should stop momentum
                                                                        let velocity_magnitude = (new_velocity_x * new_velocity_x + new_velocity_y * new_velocity_y).sqrt();
                                                                        if velocity_magnitude < 0.1 {
                                                                            set_animating_momentum.set(false);
                                                                        }
                                                                    }) as Box<dyn FnMut()>).as_ref().unchecked_ref(),
                                                                    16 // ~60fps
                                                                )
                                                                .unwrap();
                                                        }
                                                    }) as Box<dyn FnMut()>).as_ref().unchecked_ref(),
                                                    16 // ~60fps
                                                )
                                                .unwrap();
                                        }
                                    }
                                };
                                
                                // Start the momentum animation loop
                                start_momentum_animation();
                            }
                        }
                    }
                }
            }
        >
            {children()}
        </div>
    }
}

/// Simple MotionSpan component for animated span elements
#[component]
pub fn MotionSpan(
    /// CSS class name
    #[prop(optional)]
    class: Option<String>,
    /// Inline CSS styles
    #[prop(optional)]
    style: Option<String>,
    /// Initial animation state
    #[prop(optional)]
    initial: Option<AnimationTarget>,
    /// Target animation state
    #[prop(optional)]
    animate: Option<Rc<dyn Fn() -> AnimationTarget>>,
    /// Transition configuration
    #[prop(optional)]
    transition: Option<Transition>,
    /// Hover animation state
    #[prop(optional)]
    while_hover: Option<AnimationTarget>,
    /// Tap animation state
    #[prop(optional)]
    while_tap: Option<AnimationTarget>,
    /// Children elements
    children: Children,
) -> impl IntoView {
    // Create signals for animation state
    let (is_hovered, set_hovered) = signal(false);
    let (is_tapped, set_tapped) = signal(false);
    let (current_styles, set_styles) = signal(HashMap::<String, String>::new());

    // Create a reactive signal for the current animation state
    let (current_animation, set_current_animation) = signal(HashMap::new());

    // Effect that tracks animation changes - this establishes reactive dependencies
    Effect::new(move |_| {
        if let Some(animate_closure) = &animate {
            // Call the closure - this should establish reactive dependencies
            let animate_target = animate_closure();
            set_current_animation.set(animate_target);
        }
    });

    // Effect that applies styles based on current animation state
    Effect::new(move |_| {
        let mut styles = HashMap::new();
        
        // Apply initial styles
        if let Some(initial_target) = &initial {
            for (key, value) in initial_target {
                styles.insert(key.clone(), value.to_string_value());
            }
        }
        
        // Apply current animation styles
        let animation_target = current_animation.get();
        for (key, value) in &animation_target {
            styles.insert(key.clone(), value.to_string_value());
        }
        
        // Apply hover styles
        if is_hovered.get() {
            if let Some(hover_target) = &while_hover {
                for (key, value) in hover_target {
                    styles.insert(key.clone(), value.to_string_value());
                }
            }
        }
        
        // Apply tap styles
        if is_tapped.get() {
            if let Some(tap_target) = &while_tap {
                for (key, value) in tap_target {
                    styles.insert(key.clone(), value.to_string_value());
                }
            }
        }
        
        set_styles.set(styles);
    });

    // Convert styles to CSS string
    let style_string = move || {
        let mut styles = current_styles.get();
        
        // Add inline styles if provided
        if let Some(inline_style) = &style {
            styles.insert("inline".to_string(), inline_style.clone());
        }
        
        styles
            .iter()
            .filter(|(key, _)| key != &"inline")
            .map(|(key, value)| format!("{}: {}", key, value))
            .collect::<Vec<_>>()
            .join("; ")
    };

    view! {
        <span
            class=class
            style=style_string()
            on:mouseenter=move |_| set_hovered.set(true)
            on:mouseleave=move |_| {
                set_hovered.set(false);
                set_tapped.set(false);
            }
            on:mousedown=move |_| set_tapped.set(true)
            on:mouseup=move |_| set_tapped.set(false)
        >
            {children()}
        </span>
    }
}
