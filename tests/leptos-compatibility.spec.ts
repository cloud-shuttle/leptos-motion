import { test, expect } from '@playwright/test';

test.describe('Leptos v0.8.x Compatibility - TDD Approach', () => {
  test.beforeEach(async ({ page }) => {
    // Listen for console messages to debug
    page.on('console', msg => console.log('PAGE LOG:', msg.text()));
    page.on('pageerror', error => console.log('PAGE ERROR:', error.message));
    
    await page.goto('/');
    // Wait for WASM to load
    await page.waitForTimeout(2000);
  });

  test('Step 1: Check if Leptos runtime is loaded', async ({ page }) => {
    // Check if Leptos runtime functions are available
    const hasLeptosRuntime = await page.evaluate(() => {
      return typeof (window as any).leptos !== 'undefined';
    });
    
    console.log('Has Leptos runtime:', hasLeptosRuntime);
    
    // Take screenshot for debugging
    await page.screenshot({ path: 'test-step1-leptos-runtime.png' });
    
    // For now, we expect this to fail (TDD approach)
    expect(hasLeptosRuntime).toBe(true);
  });

  test('Step 2: Check if WASM module exports Leptos functions', async ({ page }) => {
    // Check if our WASM module exports the expected functions
    const wasmExports = await page.evaluate(() => {
      return {
        hasInit: typeof (window as any).init !== 'undefined',
        hasMain: typeof (window as any).main !== 'undefined',
        hasLeptosMount: typeof (window as any).leptos_mount !== 'undefined',
        hasLeptosView: typeof (window as any).leptos_view !== 'undefined',
      };
    });
    
    console.log('WASM exports:', wasmExports);
    
    await page.screenshot({ path: 'test-step2-wasm-exports.png' });
    
    // We expect at least init to be available
    expect(wasmExports.hasInit).toBe(true);
  });

  test('Step 3: Check if DOM manipulation works at all', async ({ page }) => {
    // Test if we can manipulate the DOM from JavaScript
    const domManipulationWorks = await page.evaluate(() => {
      try {
        const testDiv = document.createElement('div');
        testDiv.textContent = 'DOM Test';
        testDiv.style.background = 'red';
        testDiv.style.color = 'white';
        testDiv.style.padding = '20px';
        document.body.appendChild(testDiv);
        
        const found = document.body.contains(testDiv);
        document.body.removeChild(testDiv);
        return found;
      } catch (e) {
        console.error('DOM manipulation failed:', e);
        return false;
      }
    });
    
    console.log('DOM manipulation works:', domManipulationWorks);
    
    await page.screenshot({ path: 'test-step3-dom-manipulation.png' });
    
    expect(domManipulationWorks).toBe(true);
  });

  test('Step 4: Check if Leptos view! macro is working', async ({ page }) => {
    // Check if the view! macro generated valid HTML
    const hasViewMacroOutput = await page.evaluate(() => {
      // Look for any content that might have been generated by Leptos
      const body = document.body;
      const hasContent = body.innerHTML.trim().length > 0;
      const hasTextContent = body.textContent && body.textContent.trim().length > 0;
      
      return { hasContent, hasTextContent, bodyHTML: body.innerHTML, bodyText: body.textContent };
    });
    
    console.log('View macro output:', hasViewMacroOutput);
    
    await page.screenshot({ path: 'test-step4-view-macro.png' });
    
    // We expect this to fail initially (TDD approach)
    expect(hasViewMacroOutput.hasContent).toBe(true);
  });

  test('Step 5: Check browser console for Leptos-specific errors', async ({ page }) => {
    // Wait a bit for any errors to appear
    await page.waitForTimeout(3000);
    
    // Check if there are any Leptos-specific error messages
    const consoleMessages = await page.evaluate(() => {
      // This would normally capture console messages, but we're using page.on('console') above
      return 'Console messages captured via page.on("console")';
    });
    
    console.log('Console messages check completed');
    
    await page.screenshot({ path: 'test-step5-console-errors.png' });
    
    // This test is more about observation than assertion
    expect(true).toBe(true);
  });
});
